# 파드 소개

- 파드 : 컨테이너의 공동의 배치된 그룹. 쿠버네티스의 기본 빌딩 블록.
- 파드는 단일의 워커노드에서 실행된다.

### 각각의 프로세스를 자체 컨테이너에서 실행해야 하는 이유

- 컨테이너는 프로세스 자체가 하위 프로세스를 생성하지 않는 한 컨테이너당 하나의 프로세스만 실행하도록 설계됐다.
- 모든 프로세스는 동일한 표준 출력으로 로그를 남기므로 여러 프로세스를 하나의 컨테이너에서 실행하는 경우  어떤 프로세스가 어떤 내용을 기록했는지 파악하기 어려울 수 있다.
- 여러 개의 프로세스를 하나의 컨테이너로 묶으면 안되기 때문에 컨테이너를 단일 단위로 관리할 수 있는 상위 레벨 구조가 필요하다.
- 컨테이너 파드는 밀접하게 연관된 프로세스를 함께 실행하고 마치 하나의 컨테이너에서 실행되는 것처럼 동일한 환경을 제공하면서 다소 격리된 상태로 유지한다.

### 동일한 파드의 커테이너 사이의 부분 격리

- 쿠버네티스는 도커를 구성하여 각 컨테이너가 자체 세트를 가지고 있는 대신 모든 파드 컨테이너가 동일한 리눅스 네임스페이스 세트를 공유하도록 함으로써 격리시킨다.
- 파드의 모든 컨테이너는 동일한 네트워크 및 UTS 네임스페이스에서 실행되기 때문에 모두 같은 호스트 이름 및 네트워크 인터페이스를 공유한다.
- 컨테이너 파일 시스템은 대부분의 컨테이너 이미지에서 나왔기 때문에 기본적으로 각 컨테이너의 파일 시스템은 다른 컨테이너와 완전히 분리돼 있다.

- 파드의 컨테이너가 동일한 네트워크에서 실행되므로 네임스페이스의 경우 같은 IP 주소와 포트 공간을 공유한다. 즉, 동일한 파드의 컨테이너에서 실행 중인 프로세스는 동일한 포트 번호에 바인딩되지 않도록 주의해야 한다.

- 각 파드는 라우팅 가능한 IP 주소를 가지며 파드 전용으로 설정된 네트워크를 통해 다른 모든 파드에 액세스할 수 있다.

### 일반적으로 파드는 단일 컨테이너만 포함한다.

- 파드는 스케일링의 기본 단위.
- 하나의 파드에 다수의 컨테이너를 배치는 주요 프로세스 하나와 하나 이상의 보조 프로세스로 구성되는 경우.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/32cea591-824b-4a80-8960-cec4f3b492df/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/32cea591-824b-4a80-8960-cec4f3b492df/Untitled.png)

    - 추가 컨테이너(사이드카 컨테이너)
- 파드에서 다수의 컨테이너를 사용할 때 결정할 사항
    1. 컨테이너가 같이 실행돼야 할 필요가 있거나 혹은 다른 호스트에서 실행할 수 있는가?
    2. 컨테이너가 단일화된 전체를 표현하거나 혹은 컴포넌트가 독립적인가?
    3. 함께 혹은 개별적으로 컨테이너의 크기가 조정돼야 하는가?

# YAML이나 JSON 파일 디스크립터에서 파드 만들기

- 파드나 그 밖의 쿠버네티스 리소스는 일반적으로 JSON 또는 YAML 매니페스트를 쿠버네티스 REST API 엔드포인트에 게시해 생성한다.
    - 모든 쿠버네티스 객체를 YAML 파일로 정의하면 버전 제어 시스템에 저장할 수 있다.
- **metadata**
    - 파드와 관련된 이름, 네임스페이스, 라벨, 그 밖의 정보.
- **spec**
    - 파드의 컨테이너, 볼륨, 그 밖의 데이터와 같은 파드 내용의 실제 설명.
- **status**
    - 파드의 상태, 각 컨테이너의 설명 및 상태, 파드 내부의 IP 및 그 밖의 기본 정보 등 실행 중인 파드의 현재 정보.
    - 지정된 순간의 리소스 상태를 보여주는 읽기 전용 런타임 데이터.
    - 새로운 파드를 만들 때 status 부분을 제공할 필요가 없다.

```yaml
# 기본적인 파드 매니페스트
apiVersion: v1
kind: Pod
metadata:
  name: kubia-manual
spec:
  containers:
  - image: winnerhj1109/kubia
    name: kubia
    ports:
    - containerPort: 8080
      protocol: TCP
```

- `kubectl explain` : 사용 가능한 API 객체 찾기.
- `kubectl create -f <pod-name>` : YAML 파일에서 파드 만들기.
- `kubectl get po <pod-name> -o yaml` : 파드의 전체 YAML 조회.
- `kubectl get po <pod-name> -o json` : 파드의 전체 JSON 조회.
- `docker logs <container-id>` : 컨테이너 로그 조회.
    - 컨테이너화된 애플리케이션은 대개 로그를 파일에 스는 대신 표준 출력과 표준 오류 스트림에 기록.
- `kubectl logs <pod-name>` : 파드의 로그 조회.
- `kubectl logs <pod-name> -c <container-name>`
    - 파드에 여러 컨테이너가 있는 경우, 컨테이너 이름을 명시적으로 지정해 로그 조회.
- 파드가 삭제된 후에도 파드 로그를 사용할 수 있게 하려면 모든 로그를 중앙 스토리지에 저장하는 중앙 집중식 클러스터 전체 로깅을 설정해야 함.
- `kubectl port-forward <pod-name> 8888:8080` : 파드의 포트에 로컬 네트워크 포트 포워딩.
    - 로컬 포트 8888을 파드의 8080 포트로 전달.
    - 디버깅 등의 이유로 서비스를 거치지 않고 특정 파드와 통신하고 싶을 때, 쿠버네티스에서는 파드로 포트 포워딩을 구성할 수 있다.

<br/><br/>

# 라벨을 이용한 파드 구성

- 파드를 포함한 쿠버네티스의 모든 객체는 라벨로 구성할 수 있다.
- 라벨 : 리소스에 첨부하는 임의의 키/값 쌍.
- 파드에 라벨을 추가하면 모든 사람이 쉽게 이해할 수 있는 체계적인 시스템을 구축할 수 있다.

```yaml
# 라벨이 있는 파드 : kubia-manual-with-labels.yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-manual-v2
  labels:
    creation_method: manual
    env: prod
spec:
  containers:
  - image: winnerhj1109/kubia
    name: kubia
    ports:
    - containerPort: 8080
      protocol: TCP
```

- `kubectl get po **—-show-labels**` : 파드 *라벨 포함* 조회
- `kubectl get po **-L** <라벨 이름>` : 라벨을 지정하고 각 라벨을 지정한 열에 표시.
- `kubectl label po <파드-이름> creation-method=manual` : 파드에 라벨 추가
- `kubectl label po <파드 이름> env=debug **—-overwrite**` : 기존의 라벨 수정.
    - 기존 라벨을 변경할 때 —overwrite 옵션을 사용해야 한다.

### 라벨 셀렉터

- 라벨 셀렉터 : 특정 값의 특정 라벨을 포함하는지 여부에 따라 리소르를 필터링하는 기준.
    - 특정 키가 있는 라벨 포함(또는 포함하지 않음).
    - 특정 키와 값이 있는 라벨을 포함.
    - 특정 키가 있지만 지정한 값과 다른 값이 있는 라벨을 포함.
- kubectl get po -l createion_method=manual

### 라벨을 사용한 워커노드 분류

- 일반적으로 파드는 워커 노드 전체에서 무작위로 스케줄된다.
- 파드를 하드웨어 인프라 종류에 따라 스케줄링하고 싶은 경우, 노드 라벨 및 노드 라벨 셀렉터를 이용하자.
- 노드가 오프라인인 경우 파드가 예상치 못한 상태가 될 수 있다 → 라벨 셀렉터를 통해 지정된 특정 기준을 충족하는 노드의 논리적인 그룹을 생각해야 한다.

### 주석

- 키/값 쌍이지만, 라벨처럼 식별 정보를 보유하지 않음 → 객체 그룹화 불가능.
- `kubectl annotate pod <파드-이름> mycompany.com/someannotation="foo bar"` : 주석 추가
    - 키 충돌 방지를 위해 주석 키에 고유한 접두사를 사용한 이 형식을 사용하는 것이 좋다.
- `kubectl describe pod <파드-이름>`

<br/><br/>

# 그룹 리소스의 네임스페이스 사용하기

- 쿠버네티스 네임스페이스
    - 객체 이름의 범위를 제공.
    - 단일 네임스페이스 하나에 모든 리소스를 갖는 대신 여러 개의 네임스페이스로 분할할 수 있으므로, 동일한 리소스 이름을 여러 네임스페이스에서 여러 번 사용할 수 있다.
    - 네임스페이스를 사용하면 함께 속하지 않는 리소스를 겹치지 않는 그룹으로 분리 가능.
    - 특정 사용자에게만 특정 리소스 접근을 허용하고 , 개별 사용자가 사용할 수 있는 컴퓨팅 리소스의 양을 제한하는데도 사용됨.
- `kubectl get ns`  : 네임스페이스 조회.
- `kubectl get po --namespace kube-system`  : kube-system 네임스페이스에 속한 파드 조회.
    - 네임스페이스를 지정하지 않으면 kubectl은 현재 kubectl 컨텍스트에 구성된 기본 네임스페이스에서 작업을 수행.
    - 현재 컨텍스트의 네임스페이스와 컨텍스트 자체는 kubectl config 명령을 통해 변경 가능.
- yaml 파일로 네임스페이스 생성.

<br/><br/>

# 파드 중지와 삭제

- `kubectl delete po <파드-이름>`  : 파드 이름으로 삭제.
- `kubectl delete po -l creation_method=manual` : 라벨 셀렉터로 삭제.
- `kubectl delete ns custom-namespace` : 네임스페이스를 삭제해 파드 삭제.
- `kubectl delete po —all` : 현재 네임스페이스의 모든 파드 삭제.
- 레플리케이션컨트롤러에 의해 생성된 파드를 삭제하면 즉시 새 파드가 생성된다. 파드를 삭제하려면 레플리케이션컨트롤러도 삭제해야 한다.
- `kubectl delete all —all` : 네임스페이스의 (거의) 모든 리소스 삭제.
    - all 키워드로 모든 것을 삭제한다고 해서 모든 것이 삭제되지는 않는다.
    - 특정 리소스는 보존되어 있으므로 명시적으로 삭제해야 한다.
