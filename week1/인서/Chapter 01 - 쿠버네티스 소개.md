### 1.1 쿠버네티스와 같은 시스템이 필요한 이유
 - 모놀리스 애플리케이션 : 릴리즈 주기가 느리고 비교적 업데이트가 자주 되지 않음, 릴리즈 주기마다 개발자가 전체 시스템 패키징, 운영팀이 배포 및 모니터링
 - 마이크로서비스 : 복잡한 모놀리스 어플리케이션을 독립적으로 배포할 수 있도록 나눈 작은 구성 요소. 잘 정의된 API를 통해 다른 마이크로서비스와 통신함.
 - 거대한 모놀리스 애플리케이션을 점차 마이크로서비스로 독립되어 감. 마이크로서비스는 개별적으로 개발, 배포, 업데이트, 확장이 용이함.
 - 하지만 마이크로서비스의 수가 많아지면서 전체 시스템을 원활하게 구성, 관리, 유지하는 일이 어려워졌다.
 - 이런 시스템을 배포할 때 스케쥴링 및 구성, 관리, 장애 처리를 하는 자동화가 필요해졌고, 쿠버네티스가 이 과정에서 탄생하게 되었다.
 - 쿠버네티스는 동일한 서버에서 실행 중인 마이크로서비스의 종속성이 충돌되는 부분을 관리해주고, 애플리케이션에 일관된 환경 제공해준다.
 - 쿠버네티스는 개발자가 하드웨어 인프라를 전혀 알지 못하더라도 애플리케이션을 직접 배포하도록 해준다. 이를 노옵스(NoOps)라고 한다.

### 1.2 컨테이너 기술 소개
 - 쿠버네티스는 애플리케이션을 격리하기 위해 리눅스 컨테이너 기술을 사용한다.
 - 컨테이너는 동일한 호스트 시스템에서 여러개의 서비스를 서로 다른 환경에서 실행시킬 수 있다. 이는 가상머신과 유사하지만 오버헤드가 훨씬 적다.
 - 컨테이너에서 실행되는 프로세스는 호스트 운영체제 내에서 실행되지만 다른 프로세스와 격리되있다. 이는 분리된 운영체제에서 하이퍼바이저를 통해 프로세스를 실행하는 가상머신과의 가장 큰 차이이다.
 - 컨테이너는 리눅스 네임스페이스를 통해 프로세스를 격리시키며, 리눅스 컨트롤 그룹을 통하여 사용할 수 있는 리소스의 양을 제한한다.
 - 도커 : 애플리케이션을 패키징, 배포, 실행하기 위한 플랫폼. 전체 환경과 함께 패키지가 가능하다.
   - 이미지 : 애플리케이션과 해당 환경을 패키지화한 것
   - 레지스트리 : 도커 이미지를 저장하고 다른 사람이나 컴퓨터 간에 이미리를 쉽게 공유할 수 있는 장소
   - 컨테이너 : 도커 기반 컨테이너 이미지에서 생성된 일반적인 리눅스 컨테이너
 - 도커를 위주로 설명하기는 했지만 rkt 등 다른 컨테이너 기반 오케스트레이션도 쿠버네티스에서는 가능하다.

### 1.3 쿠버네티스 소개
 - 쿠버네티스는 구글의 보그, 오메가 등의 내부 시스템을 기반으로 만들어진 오픈소스 시스템이다.
 - 쿠버네티스는 개발자가 어플리케이션 핵심 기능에 집중할 수 있도록 하고, 운영 팀이 효과적으로 리소스를 활용할 수 있도록 지원한다.
 - 크게 마스터 노드와 워커노드로 구분할 수 있다.
   - 마스터 노드는 전체 쿠버네티스 시스템을 제어하고 관리하는 쿠버네티스 컨트롤 플레인을 실행한다.
   - 워커 노드는 실제 배포되는 컨테이너 어플리케이션을 실행한다.
 - 컨트롤 플레인은 클러스터를 제어하고 작동시킨다.
   - 쿠버네티스 API 서버는 사용자, 컨트롤플레인 구성 요소와 통신한다.
   - 스케줄러는 애플리케이션의 배포를 담당한다.
   - 컨트롤러 매니저는 클러스터단의 기능을 수행한다.
   - etcd는 클러스터 구성을 지속적으로 저장하는 분산 데이터 저장소다.
 - 워커 노드는 컨테이너화된 애플리케이션을 실행하는 시스템이다.
   - 컨테이너를 실행하는 도커, rkt 또는 다른 컨테이너 런타임
   - API 서버와 통신하고 노드의 컨테이너를 관리하는 Kubelet
   - 애플리케이션 구성 요소 간에 네트워크 트래픽을 로드밸런싱하는 쿠버네티스 서비스 프록시
 - 쿠버네티스 사용의 장점 : 애플리케이션 배포의 단순화, 하드웨어 활용도 높이기, 상태 확인과 자가 치유, 오토스케일링, 애플리케이션 개발 단순화
